{"ast":null,"code":"import _asyncToGenerator from \"/Users/klaushougesen/_repos/consulting/lahi/github/duet-example-angular/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n\n/*!\n * Built with Duet Design System\n */\nimport { r as registerInstance, h, H as Host, g as getElement, c as createEvent } from './index-795979f3.js';\nimport { s as sanitizeString, g as getLocaleString } from './language-utils-344d894c.js';\nimport { i as inheritGlobalTheme } from './themeable-component-572685dd.js';\nimport { m as mediaQueryMedium, h as mediaQueryLarge, i as mediaQueryXLarge, j as mediaQueryXxLarge, k as mediaQueryXxxLarge, l as mediaQuerySmall, n as sizeNavigation, s as sizeHeader } from './tokens.module-49cbf963.js';\nimport { c as createID } from './create-id-981107da.js';\nimport './string-utils-2f1793b8.js';\n\nconst debounce = (func, timeout = 50) => {\n  let timer;\n  return (...args) => {\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      func.apply(undefined, args);\n    }, timeout);\n  };\n};\n/**\n * Produces a function which uses template strings to do simple interpolation from objects.\n *\n * Usage:\n *    var makeMeKing = generateTemplateFn('${name} is now the king of ${country}!');\n *\n *    console.log(makeMeKing({ name: 'Bryan', country: 'Scotland'}));\n *    // Logs 'Bryan is now the king of Scotland!'\n */\n\n\nconst generateTemplateFn = function () {\n  const cache = {};\n\n  function generateTemplate(template) {\n    if (typeof template !== \"string\") {\n      template = template.outerHTML;\n    }\n\n    let fn = cache[template];\n\n    if (!fn) {\n      // Replace ${expressions} (etc) with ${map.expressions}.\n      const sanitized = template.replace(/\\$\\{([\\s]*[^;\\s\\{]+[\\s]*)\\}/g, function (_, match) {\n        return `\\$\\{map.${match.trim()}\\}`;\n      }) // Afterwards, replace anything that's not ${map.expressions}' (etc) with a blank string.\n      .replace(/(\\$\\{(?!map\\.)[^}]+\\})/g, \"\");\n      fn = Function(\"map\", `return \\`${sanitized}\\``);\n    }\n\n    return fn;\n  }\n\n  return generateTemplate;\n}();\n\nconst duetEditableTableCss = \"duet-editable-table{box-sizing:border-box;padding:0;margin:0;background:transparent;border:0;-moz-appearance:none;-webkit-appearance:none;appearance:none}.duet-editable-table-header tr .duet-editable-table-header-hidden{padding:0 !important;font-size:0;border-bottom:0}\";\nlet DuetEditableTable = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n    this.template = undefined;\n    /**\n     * State() variables\n     * @internal\n     */\n\n    this.tick = Date.now();\n    /**\n     * Map of items that contain list of things.\n     */\n\n    this.items = new Map();\n    /**\n     * Key used to set vertical alignment of action buttons\n     */\n\n    this.alignment = \"middle\";\n    /**\n     * Array of internationalized defaults for the default groups labels.\n     */\n\n    this.groupsLabelDefaults = {\n      fi: \"Kaikki\",\n      en: \"All items\",\n      sv: \"Alla objekt\"\n    };\n    /**\n     * Array of internationalized defaults for the default action labels.\n     */\n\n    this.actionLabelDefaults = {\n      fi: \"Toiminnot\",\n      en: \"Actions\",\n      sv: \"Handlingar\"\n    };\n    /**\n     * Array of group names that you want the editable table to display (can be used to hide or show groups depending on conditions).\n     * @default { id: \"all\", label: this.groupsLabelDefaults, actionLabel: this.actionLabelDefaults }.\n     * @example [{ id: \"success\", label: {fi: \"Onnistunut\", en: \"Success\", sv: \"Alt klart\", }}].\n     */\n\n    this.groups = [{\n      id: \"all\",\n      label: this.groupsLabelDefaults,\n      actionLabel: this.actionLabelDefaults\n    }];\n    /**\n     * Array of actions that are mapped via the map variable to the various groups defined in group.\n     * @default undefined\n     * @example [{\n                variation: \"default\",\n                icon: \"action-edit-2\",\n                id: \"edit\",\n                map: [\"success\"],\n                label: {\n                  fi: \" Label\",\n                  en: \" Label\",\n                  sv: \" Label\",\n                }\n              }]\n     */\n\n    this.actions = undefined;\n    /**\n     * Shows or hides the table labels.\n     */\n\n    this.hideGroups = false;\n    /**\n     * Exposes the aria role for optimizing accessibility.\n     */\n\n    this.accessibleRole = undefined;\n    /**\n     * Theme of the table.\n     */\n\n    this.theme = \"\";\n    /**\n     * Private methods.\n     */\n\n    this.kick = debounce(() => {\n      this.tick = Date.now();\n    }, 100); // will trigger re-render\n\n    /**\n     * If a user defines a template section within editable table, try to read an use it.\n     */\n\n    this.getTemplate = () => {\n      const templateDom = this.element.getElementsByTagName(\"template\");\n\n      if (templateDom === null || templateDom === void 0 ? void 0 : templateDom.length) {\n        const templateString = templateDom[0].content.firstElementChild.outerHTML;\n        return generateTemplateFn(templateString);\n      } else {\n        return false;\n      }\n    };\n\n    this.getItemData = data => {\n      const {\n        item,\n        group,\n        uid\n      } = data;\n\n      if (this.template) {\n        return {\n          group,\n          uid,\n          item: this.template(item)\n        };\n      }\n\n      return {\n        item,\n        group,\n        uid\n      };\n    };\n\n    this.filterMap = needle => {\n      if (needle === \"all\") {\n        return Array.from(this.items);\n      }\n\n      return Array.from(this.items).filter(item => needle === item[1].group);\n    };\n  }\n  /**\n   * Component lifecycle events.\n   */\n\n\n  componentWillLoad() {\n    // look for a <template> region in the duet-editable-table\n    this.template = this.getTemplate(); // take care of the case where groups and actions are defined as html properties instead of javascript objects\n\n    if (typeof this.groups === \"string\") {\n      this.internalGroupArray = sanitizeString(this.groups);\n    } else {\n      this.internalGroupArray = this.groups;\n    }\n\n    if (typeof this.actions === \"string\") {\n      this.internalActionsArray = sanitizeString(this.actions);\n    } else {\n      this.internalActionsArray = this.actions;\n    }\n\n    inheritGlobalTheme(this);\n  }\n  /**\n   * Method to force an update of a tabular data array.\n   * when called the method will rerender the entire tabular structure.\n   */\n\n\n  updateTable(passedItems = undefined) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      _this.items = new Map(passedItems || _this.items);\n\n      _this.kick();\n    })();\n  }\n\n  render() {\n    return h(Host, {\n      class: {\n        \"duet-theme-turva\": this.theme === \"turva\"\n      }\n    }, this.internalGroupArray.map(group => {\n      const currentGroup = this.filterMap(group.id);\n\n      if (!currentGroup.length) {\n        return;\n      }\n\n      return h(\"duet-table\", {\n        variation: \"plain\",\n        breakpoint: \"none\",\n        role: \"\",\n        margin: this.hideGroups ? \"none\" : \"auto\"\n      }, h(\"table\", {\n        class: \"duet-editable-table\",\n        \"aria-role\": this.accessibleRole\n      }, h(\"thead\", {\n        class: \"duet-editable-table-header\"\n      }, h(\"tr\", null, h(\"th\", {\n        class: {\n          \"duet-editable-table-header-hidden\": this.hideGroups\n        }\n      }, !this.hideGroups ? getLocaleString(group.label) : h(\"duet-visually-hidden\", null, getLocaleString(group.label))), h(\"th\", {\n        class: {\n          \"duet-editable-table-header-hidden\": this.hideGroups\n        }\n      }, h(\"duet-visually-hidden\", null, group.actionLabel ? getLocaleString(group.actionLabel) : getLocaleString(this.actionLabelDefaults))))), h(\"tbody\", null, currentGroup.map(dataAsArray => {\n        const [key, value] = dataAsArray;\n        return h(\"duet-editable-table-item\", {\n          theme: this.theme,\n          keyName: key,\n          data: this.getItemData(value),\n          groupId: group.id,\n          part: group.id,\n          alignment: this.alignment,\n          actions: this.internalActionsArray\n        });\n      }))));\n    }));\n  }\n\n  get element() {\n    return getElement(this);\n  }\n\n};\nDuetEditableTable.style = duetEditableTableCss; //simple functional component that renders the data in the table\n\nconst TableData = ({\n  data,\n  groupId,\n  alignment\n}, _children) => {\n  if (typeof data === \"string\") {\n    return h(\"td\", {\n      innerHTML: data,\n      class: \"duet-editable-table-content\",\n      part: `${groupId}content`,\n      style: {\n        verticalAlign: alignment\n      }\n    });\n  } else {\n    return h(\"td\", {\n      class: \"duet-editable-table-content\",\n      part: `${groupId}content`,\n      style: {\n        verticalAlign: alignment\n      }\n    }, data);\n  }\n};\n\nconst duetEditableTableItemCss = \"*,*::after,*::before{box-sizing:border-box;padding:0;margin:0;background:transparent;border:0;-moz-appearance:none;-webkit-appearance:none;appearance:none}:host{display:table-row;height:32px}.duet-editable-table-content,.duet-editable-table-actions{height:32px;padding:12px 0;vertical-align:middle;break-word:break-all;border-bottom:1px solid #e1e3e6}.duet-editable-table-actions-items{display:flex;justify-content:flex-end}.duet-editable-table-actions-items duet-editable-table-button{padding-left:8px}.duet-editable-table .editable-item-small{font-size:0.75rem;font-weight:400}\";\nlet DuetEditableTableItem = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n    this.duetEditableItemAction = createEvent(this, \"duetEditableItemAction\", 7);\n    this.isHovering = false;\n    /**\n     * Theme of the empty state component.\n     */\n\n    this.theme = \"\";\n    /**\n     * Actions that can be performed on the element\n     */\n\n    this.actions = undefined;\n    /**\n     * GroupId used to pierce the shadowdom - gets concatenated with \"content & actions\" and used as part=\"groupIDcontent/actions\" to pierce the content/Action item\n     * @internal\n     */\n\n    this.groupId = \"\";\n    /**\n     * Key used to set vertical alignment of action buttons\n     */\n\n    this.alignment = \"middle\";\n    /**\n     * Key used to identify item, when running actions\n     */\n\n    this.keyName = \"\";\n    /**\n     * Object of data itemsused to render the entire row\n     */\n\n    this.data = undefined;\n  }\n\n  watchPropHandler(_newValue, _oldValue) {// console.log(\"The new value of activated is: \", _newValue)\n  }\n  /**\n   /**\n   * Component lifecycle events.\n   */\n\n\n  componentWillLoad() {\n    inheritGlobalTheme(this);\n  }\n  /**\n   /**\n   * private functions\n   */\n\n  /**\n   * render() function\n   * Always the last one in the class.\n   */\n\n\n  render() {\n    return h(Host, {\n      role: \"row\"\n    }, h(TableData, {\n      data: this.data.item,\n      alignment: this.alignment,\n      groupId: this.groupId\n    }), h(\"td\", {\n      class: \"duet-editable-table-actions\",\n      style: {\n        verticalAlign: this.alignment\n      }\n    }, h(\"div\", {\n      class: \"duet-editable-table-actions-items\",\n      part: `${this.groupId}actions`\n    }, this.actions.map(result => {\n      const {\n        map = undefined\n      } = result; // if map has been specified, only show the current action if groupID matches the map array\n\n      if (map && !map.includes(this.groupId)) {\n        return;\n      }\n\n      return h(\"duet-editable-table-button\", {\n        keyName: this.keyName,\n        group: this.data.group,\n        uid: this.data.uid,\n        actions: result,\n        theme: this.theme\n      });\n    }))));\n  }\n\n  get el() {\n    return getElement(this);\n  }\n\n  static get watchers() {\n    return {\n      \"data\": [\"watchPropHandler\"]\n    };\n  }\n\n};\nDuetEditableTableItem.style = duetEditableTableItemCss;\nconst duetTableCss = \"duet-table{box-sizing:border-box;padding:0;margin:0;background:transparent;border:0;-moz-appearance:none;-webkit-appearance:none;appearance:none;margin-bottom:20px !important;display:block;font-variant-numeric:tabular-nums}duet-table table,duet-table thead,duet-table tbody,duet-table tfoot,duet-table th,duet-table td,duet-table tr{box-sizing:border-box;padding:0;margin:0;background:transparent;border:0;-moz-appearance:none;-webkit-appearance:none;appearance:none}duet-table.duet-m-0{margin:0 !important}duet-table table{width:100%;font-family:\\\"localtapiola-sans\\\", -apple-system, BlinkMacSystemFont, \\\"Segoe UI\\\", Roboto, Helvetica, Arial, sans-serif, \\\"Apple Color Emoji\\\", \\\"Segoe UI Emoji\\\", \\\"Segoe UI Symbol\\\";font-size:1rem;text-align:left;border-spacing:0;border-collapse:separate}duet-table.duet-theme-turva table{font-family:\\\"turva-sans\\\", -apple-system, BlinkMacSystemFont, \\\"Segoe UI\\\", Roboto, Helvetica, Arial, sans-serif, \\\"Apple Color Emoji\\\", \\\"Segoe UI Emoji\\\", \\\"Segoe UI Symbol\\\"}duet-table td{-webkit-hyphens:auto;hyphens:auto;color:#00294d}duet-table.duet-theme-turva td{color:#171c3a}duet-table th{font-weight:600;line-height:1.25;color:#657787;text-align:left}duet-table.duet-theme-turva th{color:#747475}duet-table tbody th{font-weight:600;color:#00294d}duet-table.duet-theme-turva tbody th{color:#171c3a}.duet-table-flattened table,.duet-table-flattened thead,.duet-table-flattened tbody,.duet-table-flattened tfoot,.duet-table-flattened th,.duet-table-flattened td,.duet-table-flattened tr{display:block}.duet-table-flattened thead tr{position:absolute !important;top:0;width:1px !important;height:1px !important;padding:0 !important;overflow:hidden !important;clip:rect(1px, 1px, 1px, 1px) !important;border:0 !important}.duet-table-flattened td{line-height:1.25}.duet-table-flattened td:not(:last-child){margin-bottom:16px !important}.duet-table-flattened tbody td,.duet-table-flattened tbody th,.duet-table-flattened tfoot td{padding:0 !important;text-align:left !important}.duet-table-flattened tbody th{font-weight:600;line-height:1.25;color:#657787;text-align:left}.duet-table-flattened td[data-heading]::before{margin-bottom:4px !important;display:block;font-size:1rem;font-weight:600;color:#00294d;content:attr(data-heading)}.duet-table-flattened.duet-theme-turva td[data-heading]::before{color:#171c3a}.duet-table-sticky thead th{position:sticky;top:0;background:white}.duet-table-striped td,.duet-table-striped th{padding:20px !important}@media (max-width: 35.9375em){.duet-table-striped td,.duet-table-striped th{padding:20px 12px !important}}.duet-table-striped tbody th{background:white}.duet-table-striped.duet-table-sticky thead th{border-bottom:1px solid #e1e3e6}.duet-table-striped.duet-table-sticky.duet-theme-turva thead th{border-bottom-color:#e4e4e6}.duet-table-striped tbody:not(:first-of-type) th{padding-top:40px !important}.duet-table-striped tbody:only-of-type tr:nth-of-type(odd){background:rgba(0, 80, 128, 0.04)}.duet-table-striped.duet-theme-turva tbody:only-of-type tr:nth-of-type(odd){background:rgba(23, 28, 58, 0.04)}.duet-table-striped tbody:not(:only-of-type) tr:nth-of-type(even){background:rgba(0, 80, 128, 0.04)}.duet-table-striped.duet-theme-turva tbody:not(:only-of-type) tr:nth-of-type(even){background:rgba(23, 28, 58, 0.04)}.duet-table-striped tfoot td{border-top:1px solid #e1e3e6}.duet-table-striped.duet-theme-turva tfoot td{border-top-color:#e4e4e6}.duet-table-striped.duet-table-flattened tbody:not(:first-of-type) th{padding-top:20px !important}.duet-table-striped.duet-table-flattened tr{padding:20px !important}.duet-table-striped.duet-table-flattened tfoot td{border-top:0}.duet-table-striped.duet-table-flattened tfoot tr{border-top:1px solid #e1e3e6}.duet-table-striped.duet-table-flattened.duet-theme-turva tfoot tr{border-top-color:#e4e4e6}.duet-table-fixed th,.duet-table-minimal th,.duet-table-plain th{padding:16px !important;border-bottom:1px solid #657787}.duet-table-fixed th:first-child,.duet-table-minimal th:first-child,.duet-table-plain th:first-child{padding-left:0 !important}.duet-table-fixed th:last-child,.duet-table-minimal th:last-child,.duet-table-plain th:last-child{padding-right:0 !important}.duet-theme-turva.duet-table-fixed th,.duet-theme-turva.duet-table-minimal th,.duet-theme-turva.duet-table-plain th{border-bottom-color:#444445}.duet-table-fixed tbody th,.duet-table-minimal tbody th,.duet-table-plain tbody th{padding-top:40px !important;border-bottom-color:#e1e3e6}.duet-theme-turva.duet-table-fixed tbody th,.duet-theme-turva.duet-table-minimal tbody th,.duet-theme-turva.duet-table-plain tbody th{border-bottom-color:#e4e4e6}.duet-table-fixed td,.duet-table-minimal td,.duet-table-plain td{padding:16px !important}.duet-table-fixed td:first-child,.duet-table-minimal td:first-child,.duet-table-plain td:first-child{padding-left:0 !important}.duet-table-fixed td:last-child,.duet-table-minimal td:last-child,.duet-table-plain td:last-child{padding-right:0 !important}.duet-table-fixed tbody td,.duet-table-minimal tbody td,.duet-table-plain tbody td{border-bottom:1px solid #e1e3e6}.duet-theme-turva.duet-table-fixed tbody td,.duet-theme-turva.duet-table-minimal tbody td,.duet-theme-turva.duet-table-plain tbody td{border-bottom-color:#e4e4e6}.duet-table-flattened.duet-table-fixed tbody:first-of-type th,.duet-table-flattened.duet-table-minimal tbody:first-of-type th,.duet-table-flattened.duet-table-plain tbody:first-of-type th{padding-top:0 !important}.duet-table-flattened.duet-table-fixed td,.duet-table-flattened.duet-table-minimal td,.duet-table-flattened.duet-table-plain td,.duet-table-flattened.duet-table-fixed tbody th,.duet-table-flattened.duet-table-minimal tbody th,.duet-table-flattened.duet-table-plain tbody th{border-bottom:0}.duet-table-flattened.duet-table-fixed tr,.duet-table-flattened.duet-table-minimal tr,.duet-table-flattened.duet-table-plain tr{padding:20px 0 !important}.duet-table-flattened.duet-table-fixed tbody th,.duet-table-flattened.duet-table-minimal tbody th,.duet-table-flattened.duet-table-plain tbody th{padding-top:20px !important}.duet-table-flattened.duet-table-fixed tfoot td,.duet-table-flattened.duet-table-minimal tfoot td,.duet-table-flattened.duet-table-plain tfoot td{margin-bottom:4px !important}.duet-table-flattened.duet-table-fixed tbody:not(:only-of-type) tr:first-child,.duet-table-flattened.duet-table-minimal tbody:not(:only-of-type) tr:first-child,.duet-table-flattened.duet-table-plain tbody:not(:only-of-type) tr:first-child{border-bottom:0}.duet-table-plain.duet-table-flattened tbody tr{border-bottom:1px solid #e1e3e6}.duet-table-plain.duet-table-flattened.duet-theme-turva tbody tr{border-bottom-color:#e4e4e6}.duet-table-minimal tbody tr,.duet-table-minimal tbody tr td{vertical-align:top;border-bottom:0 none}.duet-table-minimal tbody tr:last-of-type,.duet-table-minimal tbody tr:last-of-type td{border-bottom:1px solid #e1e3e6}.duet-table-minimal.duet-table-flattened tbody tr,.duet-table-minimal.duet-table-flattened tbody tr td{border-bottom:0 none}.duet-table-minimal.duet-table-flattened tbody tr td[data-heading]::before{display:none}.duet-table-minimal.duet-table-flattened tfoot{border-top:1px solid #e1e3e6}.duet-table-minimal.duet-table-flattened.duet-theme-turva tfoot{border-top-color:#e4e4e6}.duet-table-fixed table{table-layout:fixed}.duet-table-fixed tbody tr,.duet-table-fixed tbody tr td,.duet-table-fixed tbody tr td:first-child{padding:4px !important;vertical-align:text-bottom;border-bottom:0 none}.duet-table-fixed thead{display:none}.duet-table-fixed tbody tr,.duet-table-fixed tbody tr td{border-bottom:0 none}.duet-table-fixed:not(.duet-table-flattened) tfoot{border-top:1px solid #e1e3e6}.duet-table-fixed:not(.duet-table-flattened).duet-theme-turva tfoot{border-top-color:#e4e4e6}.duet-table-scrollable{position:relative;width:100%;overflow-x:auto;background:linear-gradient(90deg, #fff 0%, rgba(255, 255, 255, 0)), linear-gradient(-90deg, #fff 0%, rgba(255, 255, 255, 0)) 100% 0, radial-gradient(farthest-side at 0% 50%, rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0)), radial-gradient(farthest-side at 100% 50%, rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0)) 100% 0%;background-repeat:no-repeat;background-attachment:local, local, scroll, scroll;background-size:100px 100%, 100px 100%, 12px 100%, 12px 100%}.duet-table-selected-column{background:rgba(0, 119, 179, 0.08)}.duet-theme-turva .duet-table-selected-column{background:rgba(68, 68, 69, 0.08)}\"; // remove wrapping speech marks.\n// media query tokens are wrapped in speech marks,\n// which need to be removed before use with matchMedia.\n\nconst unwrap = str => str.substring(1, str.length - 1);\n\nconst breakpointToToken = {\n  none: \"all\",\n  \"none-scrollable\": \"all\",\n  small: unwrap(mediaQuerySmall),\n  medium: unwrap(mediaQueryMedium),\n  large: unwrap(mediaQueryLarge),\n  \"x-large\": unwrap(mediaQueryXLarge),\n  \"xx-large\": unwrap(mediaQueryXxLarge),\n  \"xxx-large\": unwrap(mediaQueryXxxLarge)\n};\nconst stickyTopValues = {\n  none: 0,\n  \"with-links\": parseFloat(sizeNavigation) * 16,\n  \"without-links\": parseFloat(sizeHeader) * 16\n};\nlet DuetTable = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n    /**\n     * Tracks whether the breakpoint is matched. This is set to true by default so that JavaScript disabled in SSR mode we get accessible table data first.\n     */\n\n    this.matchesBreakpoint = true;\n    /**\n     * Controls the margin of the component.\n     */\n\n    this.margin = \"auto\";\n    /**\n     * Style variation of the table.\n     */\n\n    this.variation = \"striped\";\n    /**\n     * Controls whether the table has a sticky header.\n     * Sticky headers are not compatible with breakpoint=\"none-scrollable\".\n     */\n\n    this.sticky = false;\n    /**\n     * Adjust the distance from top of the viewport (in pixels) when the\n     * table header becomes sticky.\n     */\n\n    this.stickyDistance = \"with-links\";\n    /**\n     * By default the table is responsive - it will be flattened at narrow viewport widths.\n     * This prop controls the breakpoint at which the table should be rendered as a _regular_ table.\n     * Set to \"none\" to disable the responsive functionality.\n     * Set to \"none-scrollable\" to disable responsive functionality _and_ allow horizontal scrolling -\n     * this is useful for comparison tables where it's important to maintain column and row layout.\n     */\n\n    this.breakpoint = \"small\";\n\n    this.handleMediaQueryChange = mq => {\n      this.matchesBreakpoint = mq.matches;\n    };\n  }\n\n  connectedCallback() {\n    this.mq = matchMedia(breakpointToToken[this.breakpoint]);\n    this.mq.addEventListener(\"change\", this.handleMediaQueryChange);\n    this.handleMediaQueryChange(this.mq);\n    this.observer = new MutationObserver(() => this.copyHeadingsToCells());\n    this.observer.observe(this.element, {\n      childList: true,\n      subtree: true\n    });\n  }\n\n  componentWillLoad() {\n    inheritGlobalTheme(this);\n    this.copyHeadingsToCells();\n\n    if (this.sticky && this.breakpoint === \"none-scrollable\") {\n      console.warn(`[DUET WARNING]: sticky and breakpoint=\"none-scrollable\" are incompatible. Scrollable takes precedence`);\n    }\n\n    if (this.sticky) {\n      const stickyTop = stickyTopValues[this.stickyDistance];\n      const headingElements = this.element.querySelectorAll(\"thead th\");\n      headingElements.forEach(th => th.style.top = `${stickyTop}px`);\n    }\n  }\n\n  componentDidLoad() {\n    // this clears all pending mutations,\n    // that way we avoid dealing with any initial changes\n    // and only get genuine mutations as rows are added/removed\n    this.observer.takeRecords();\n  }\n\n  disconnectedCallback() {\n    this.observer.disconnect();\n    this.observer = null;\n    this.mq.removeListener(this.handleMediaQueryChange);\n    this.mq = null;\n    this.matchesBreakpoint = true;\n  }\n\n  copyHeadingsToCells() {\n    const headingElements = this.element.querySelectorAll(\"thead th\");\n    const rowElements = this.element.querySelectorAll(\"tbody tr\");\n    const headings = Array.from(headingElements).map(th => th.textContent.trim());\n    rowElements.forEach(tr => {\n      tr.querySelectorAll(\"td\").forEach((td, i) => {\n        if (headings[i]) {\n          td.dataset.heading = headings[i];\n        }\n      });\n    });\n  }\n\n  render() {\n    return h(Host, {\n      class: {\n        [`duet-table-${this.variation}`]: true,\n        \"duet-table-flattened\": !this.matchesBreakpoint,\n        // sticky only valid when in regular table layout\n        \"duet-table-sticky\": this.matchesBreakpoint && this.sticky,\n        \"duet-table-scrollable\": this.breakpoint === \"none-scrollable\",\n        \"duet-m-0\": this.margin === \"none\",\n        \"duet-theme-turva\": this.theme === \"turva\"\n      }\n    }, h(\"slot\", null));\n  }\n\n  get element() {\n    return getElement(this);\n  }\n\n};\nDuetTable.style = duetTableCss;\nconst errorCodes = [{\n  type: \"default\",\n  system_message: \"unknown error\",\n  message: {\n    fi: \"Tapahtui tuntematon virhe, ole hyvä ja yritä uudelleen.\",\n    sv: \"Ett okänt fel uppstod, försök igen.\",\n    en: \"An unknown error occured, please try again.\"\n  }\n}, {\n  type: \"400\",\n  system_message: \"Bad Request: The server could not understand the request due to invalid syntax.\",\n  message: {\n    fi: \"Tiedostoa ei hyväksytty.\",\n    sv: \"Servern avvisade din fil.\",\n    en: \"The server rejected your file.\"\n  }\n}, {\n  type: \"401\",\n  system_message: \"Not Authenticated: The client must authenticate itself to get the requested response...\",\n  message: {\n    fi: \"Vain kirjautunut käyttäjä voi lähettää tiedostoja.\",\n    sv: \"Du måste vara inloggad för att ladda upp filer.\",\n    en: \"You need to be logged in to upload files.\"\n  }\n}, {\n  type: \"403\",\n  system_message: \"No Access: The client does not have access rights to the content.\",\n  message: {\n    fi: \"Ei oikeuksia lähettää tiedostoja.\",\n    sv: \"Du har inte rätt åtkomsträttigheter för att ladda upp filer.\",\n    en: \"You do not have the correct access rights to upload files.\"\n  }\n}, {\n  type: \"413\",\n  system_message: \"Payload too large\",\n  message: {\n    fi: \"Tiedosto oli liian vastaanotettavaksi.\",\n    sv: \"Filen var för stor för servern att hantera.\",\n    en: \"The file was to large for the server to handle.\"\n  }\n}, {\n  type: \"415\",\n  system_message: \"Unsupported media type\",\n  message: {\n    fi: \"Tiedoston tyyppi oli väärä.\",\n    sv: \"Servern avvisade filen eftersom den hade fel typ.\",\n    en: \"The server rejected the file because it had the wrong type.\"\n  }\n}, {\n  type: \"429\",\n  system_message: \"Too many request from same address\",\n  message: {\n    fi: \"Liian monta yritystä, ole hyvä ja yritä myöhemmin uudelleen.\",\n    sv: \"Servern har fått många förfrågningar från dig, försök igen senare.\",\n    en: \"The server has received to many request from you, please try again later.\"\n  }\n}, {\n  type: \"500\",\n  system_message: \"Internal Server Error\",\n  message: {\n    fi: \"Palvelin ilmoitti tuntemattomasta virheestä ja lataus epäonnistui.\",\n    sv: \"Servern rapporterade ett okänt fel och uppladdningen misslyckades.\",\n    en: \"The server reported an unknown error and the upload failed.\"\n  }\n}, {\n  type: \"duet-upload-100\",\n  system_message: \"File extension not allowed\",\n  message: {\n    fi: \"Tiedoston tyyppi ei ole sallittu.\",\n    sv: \"Du kan inte ladda upp filer av den type.\",\n    en: \"You cannot upload files with that extension.\"\n  }\n}, {\n  type: \"duet-upload-001\",\n  system_message: \"File transfer failed\",\n  message: {\n    fi: \"Tiedoston lähetys keskeytyi, ole hyvä ja yritä uudelleen.\",\n    sv: \"Din anslutning till servern avbröts, försök igen.\",\n    en: \"Your connection to the server was interrupted, try again.\"\n  }\n}, {\n  type: \"duet-upload-101\",\n  system_message: \"File mimetype not allowed\",\n  message: {\n    fi: \"Tiedoston tyyppi ei ole sallittu.\",\n    sv: \"Du kan inte ladda upp filer av den typ.\",\n    en: \"You cannot upload files of that type.\"\n  }\n}, {\n  type: \"duet-upload-201\",\n  system_message: \"File is too large\",\n  message: {\n    fi: \"Tiedosto on liian iso.\",\n    sv: \"Filen är större än tillåtet.\",\n    en: \"The file is larger than permitted.\"\n  }\n}, {\n  type: \"duet-upload-202\",\n  system_message: \"The combined size of all files is too large\",\n  message: {\n    fi: \"Tiedostojen yhteenlaskettu koko on liian iso.\",\n    sv: \"Du har nått den maximala kombinerade filstorleken.\",\n    en: \"You have reached the maximum combined filesize.\"\n  }\n}, {\n  type: \"duet-upload-301\",\n  system_message: \"The maximum file limit has been reached\",\n  message: {\n    fi: \"Liitteiden maksimimäärä saavutettu.\",\n    sv: \"Maximalt antal bilagor har uppnåtts.\",\n    en: \"Maximum number of attachments reached.\"\n  }\n}];\n\nconst getError = code => {\n  let error = {\n    type: undefined,\n    system_message: undefined,\n    message: undefined\n  };\n  error = errorCodes.filter(errorItem => {\n    // the == is intentional we may be comparing numbers to strings - and that is ok here\n    return errorItem.type == code;\n  })[0];\n\n  if (!error) {\n    error = errorCodes.filter(errorItem => {\n      return errorItem.type === \"default\";\n    })[0];\n  }\n\n  return error;\n};\n\nconst getI18nError = errorCode => {\n  const errorFromJson = getError(errorCode);\n  const i18String = getLocaleString(errorFromJson.message);\n\n  if (i18String === \"\" || !i18String) {\n    return errorFromJson.system_message;\n  } else {\n    return i18String;\n  }\n};\n\nconst ErrorItem = ({\n  data\n}) => {\n  const {\n    item,\n    error\n  } = data;\n  const {\n    name\n  } = item;\n  const {\n    type\n  } = error;\n  return h(\"span\", {\n    class: \"duet-upload-item-error\",\n    role: \"status\"\n  }, h(\"duet-paragraph\", {\n    class: \"duet-upload-item-name\",\n    color: \"danger\",\n    margin: \"none\",\n    weight: \"semi-bold\"\n  }, h(\"duet-icon\", {\n    margin: \"none\",\n    size: \"xx-small\",\n    name: \"messaging-attachment\"\n  }), \" \", name), h(\"duet-paragraph\", {\n    class: \"duet-upload-item-error-label\",\n    size: \"small\",\n    margin: \"none\",\n    color: \"danger\"\n  }, getI18nError(type)));\n};\n\nconst ProgressItem = ({\n  progress,\n  name\n}) => h(\"span\", null, h(\"duet-paragraph\", {\n  color: \"secondary\",\n  margin: \"none\",\n  size: \"small\"\n}, name), h(\"duet-spacer\", {\n  size: \"xx-small\"\n}), h(\"duet-progress\", {\n  progress: Math.ceil(progress),\n  \"aria-hidden\": true\n}));\n\nconst formatBytes = (bytes, decimals = 2) => {\n  if (bytes === 0) {\n    return \"0 Bytes\";\n  }\n\n  const k = 1024;\n  const dm = decimals < 0 ? 0 : decimals;\n  const sizes = [\"Bytes\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\"];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n  return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + \" \" + sizes[i];\n};\n\nconst SuccessItem = ({\n  data,\n  showLinks\n}) => {\n  const {\n    item,\n    size,\n    uploaded,\n    url,\n    meta\n  } = data;\n  const {\n    name\n  } = item;\n  const ContentName = h(\"span\", {\n    class: \"duet-upload-item-name\"\n  }, h(\"duet-icon\", {\n    margin: \"none\",\n    size: \"xx-small\",\n    name: \"messaging-attachment\"\n  }), h(\"duet-spacer\", {\n    size: \"xx-small\",\n    direction: \"horizontal\"\n  }), name);\n  const SizeText = h(\"span\", {\n    class: \"duet-upload-item-size\",\n    style: {\n      fontSize: \"14px\",\n      fontWeight: \"400\"\n    }\n  }, \"(\", formatBytes(size), \")\");\n  const FilenameLine = uploaded && url && showLinks ? h(\"duet-paragraph\", {\n    color: \"secondary\",\n    margin: \"none\",\n    weight: \"semi-bold\"\n  }, h(\"duet-link\", {\n    url: url,\n    external: true\n  }, ContentName), h(\"duet-spacer\", {\n    size: \"xx-small\",\n    direction: \"horizontal\"\n  }), SizeText) : h(\"duet-paragraph\", {\n    color: \"secondary\",\n    margin: \"none\",\n    weight: \"semi-bold\"\n  }, ContentName, h(\"duet-spacer\", {\n    size: \"xx-small\",\n    direction: \"horizontal\"\n  }), SizeText);\n  const Badges = meta && meta.badges ? h(\"span\", null, h(\"duet-spacer\", {\n    size: \"xx-small\"\n  }), meta.badges.map(badgeText => h(\"duet-badge\", {\n    color: \"primary\"\n  }, badgeText))) : undefined;\n  return h(\"span\", {\n    class: \"duet-upload-item-success\"\n  }, h(\"div\", null, FilenameLine), Badges);\n};\n\nconst validateFileExtension = (name, allowedExtensions) => {\n  if (!allowedExtensions) {\n    return true;\n  }\n\n  const ext = name.split(\".\");\n  const validExtension = allowedExtensions.split(\",\");\n  const extension = ext[ext.length - 1];\n  return validExtension.includes(extension);\n};\n\nconst validateFileMime = (type, allowedMimetypes) => {\n  if (!allowedMimetypes || !type) {\n    return true;\n  }\n\n  const validMimeTypes = allowedMimetypes.split(\",\");\n  let valid = false;\n  validMimeTypes.forEach(mimeType => {\n    const allowedTypes = mimeType.split(\"/\");\n    const fileType = type.split(\"/\");\n\n    if (allowedTypes[0] === fileType[0] && (allowedTypes[1] === fileType[1] || allowedTypes[1] === \"*\")) {\n      valid = true;\n    }\n  });\n  return valid;\n};\n\nconst validateFileSize = (size, maxBytes) => {\n  if (!maxBytes || !size) {\n    return true;\n  }\n\n  return maxBytes >= size;\n};\n\nconst validateFile = (item, validators) => {\n  const {\n    allowedMimetypes,\n    allowedExtensions,\n    maxBytes\n  } = validators;\n  let valid = false;\n  let errorMessage = getError(\"default\");\n\n  if (item) {\n    const {\n      name,\n      type,\n      size\n    } = item;\n    const mime = validateFileMime(type, allowedMimetypes);\n    const ext = validateFileExtension(name, allowedExtensions);\n    const bytes = validateFileSize(size, maxBytes);\n\n    if (!mime) {\n      errorMessage = getError(\"duet-upload-101\");\n    }\n\n    if (!ext) {\n      errorMessage = getError(\"duet-upload-100\");\n    }\n\n    if (!bytes) {\n      errorMessage = getError(\"duet-upload-201\");\n    }\n\n    valid = mime && ext && bytes;\n  } else {\n    valid = false;\n  }\n\n  return {\n    valid,\n    errorMessage: valid ? undefined : getLocaleString(errorMessage.message),\n    errorSystem: valid ? undefined : errorMessage.system_message,\n    errorType: valid ? undefined : errorMessage.type\n  };\n};\n\nconst validateTotalSizeIsAboveMax = (filelist, maxTotalBytes) => {\n  let total = 0;\n\n  if (maxTotalBytes) {\n    filelist.forEach(item => {\n      if (item.valid && item.size) {\n        total += item.size;\n      }\n    });\n\n    if (total < maxTotalBytes) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nconst validateTotalAmountIsAboveMax = (filelist, maxFiles) => {\n  let total = 0;\n\n  if (maxFiles) {\n    filelist.forEach(item => {\n      if (item.valid) {\n        total++;\n      }\n    });\n\n    if (total > maxFiles) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nconst makeXhrRequest = ({\n  payload,\n  options,\n  onFailure,\n  onSuccess,\n  onProgress\n}) => {\n  const {\n    type = \"POST\",\n    xhr,\n    uri,\n    argument = null,\n    headers = null\n  } = options;\n  xhr.open(type, `${uri}${argument || \"\"}`, true);\n  const {\n    data,\n    name\n  } = payload; // headers must be added after open\n\n  if (headers) {\n    Object.keys(headers).forEach(key => {\n      xhr.setRequestHeader(key, headers[key]);\n    });\n  }\n\n  if (type === \"POST\") {\n    xhr.onreadystatechange = () => {\n      // Call a function when the state changes.\n      if (xhr.readyState === XMLHttpRequest.DONE && xhr.status >= 200 && xhr.status < 300) {\n        // Request finished without errors\n        onSuccess(xhr, name, xhr.status);\n      }\n\n      if (xhr.readyState === XMLHttpRequest.DONE && xhr.status >= 300 && xhr.status < 999) {\n        // Request finished with errors\n        onFailure(xhr, name, xhr.status);\n      }\n    };\n\n    onProgress(name);\n  }\n\n  xhr.send(data);\n  return xhr;\n};\n\nconst duetUploadCss = \"*,*::after,*::before{box-sizing:border-box;padding:0;margin:0;background:transparent;border:0;-moz-appearance:none;-webkit-appearance:none;appearance:none}:host{box-sizing:border-box;padding:0;margin:0;background:transparent;border:0;-moz-appearance:none;-webkit-appearance:none;appearance:none}::slotted([slot=header]){margin-bottom:16px}::slotted([slot=fileheader]){margin:16px 0 0 0}::slotted([slot=filefooter]){margin-top:16px}.duet-upload{box-sizing:border-box;padding:0;margin:0;background:transparent;border:0;-moz-appearance:none;-webkit-appearance:none;appearance:none}.duet-upload-item-size{font-size:0.75rem;font-weight:400}.duet-upload-filelist{margin-bottom:25px}.duet-upload-filelist-empty{display:flex;align-items:center;justify-content:center;width:100%;height:75px;margin:0 auto;font-size:1rem;font-weight:400;background-color:#f5f8fa}\";\nlet DuetUpload = class {\n  constructor(hostRef) {\n    var _this2 = this;\n\n    registerInstance(this, hostRef);\n    this.duetChange = createEvent(this, \"duetChange\", 3);\n    this.duetBlur = createEvent(this, \"duetBlur\", 7);\n    this.duetFocus = createEvent(this, \"duetFocus\", 7);\n    this.duetDone = createEvent(this, \"duetDone\", 3);\n    this.duetState = createEvent(this, \"duetState\", 3);\n    this.duetDelete = createEvent(this, \"duetDelete\", 3);\n    this.duetCancel = createEvent(this, \"duetCancel\", 3);\n    this.duetProgress = createEvent(this, \"duetProgress\", 3);\n    this.duetUpload = createEvent(this, \"duetUpload\", 3);\n    /**\n     * Own Properties\n     */\n\n    this.buttonId = createID(\"DuetButton\");\n    this.labelId = createID(\"DuetLabel\");\n    this.uploadId = createID(\"DuetUpload\");\n    this.editableTableId = createID(\"DuetEditableTable\");\n    this.filesInProgress = new Map();\n    this.fileMaxReached = false;\n    this.bytesMaxReached = false;\n    this.internalStatusMessageLabel = undefined;\n    /**\n     * Properties\n     */\n\n    this.DefaultGroups = {\n      inprogress: \"inprogress\",\n      success: \"success\",\n      failure: \"failure\"\n    };\n    /**\n     * State() variables\n     */\n\n    this.tick = Date.now();\n    /**\n     * If external is set to true, the upload component will not actually upload the files, but only keep states\n     * it will be up to you to handle the upload and return progress information to the upload-component\n     */\n\n    this.external = false;\n    /**\n     * If set the upload component will not display an upload button, you will have to create one yourself\n     * and call the exposed method startUpload\n     */\n\n    this.hideButton = false;\n    /**\n     * Default actions added to the internally used duet-editable-table\n     */\n\n    this.actions = [{\n      icon: \"action-delete\",\n      color: \"color-danger\",\n      color_hover: \"primary-dark\",\n      id: \"delete\",\n      map: [\"success\", \"failure\"],\n      label: {\n        fi: \"Poista tiedosto\",\n        en: \"Poista tiedosto\",\n        sv: \"Ta bort filen\"\n      }\n    }, {\n      icon: \"navigation-close\",\n      color: \"primary\",\n      color_hover: \"primary-dark\",\n      id: \"cancel\",\n      map: [\"inprogress\"],\n      label: {\n        fi: \"Keskeytä lähetys\",\n        en: \"Cancel the upload\",\n        sv: \"Stop överföringen\"\n      }\n    }];\n    /**\n     * If enabled the editable-table will display links on successfully uploaded items,\n     * this requires the server can respond with link URIs in the correct format\n     * and that the files are accessible to the user\n     */\n\n    this.showLinks = false;\n    /**\n     * Property to change the aria upload progress text read aloud by screenreaders\n     * @default {\n     *     fi: {\n     *       inProgress: \"Lähetetään {filesUploaded} lähetettävästä {filesTotal} tiedostosta\",\n     *       inProgressWithErrors:\n     *         \"Lähetetään {filesInProgress} tiedostoa, lähetetty {filesUploaded} lähetettävästä {filesTotal} tiedostosta, {filesWithErrors} tiedostossa on virheitä\",\n     *       done: \"Kaikki {filesTotal} tiedostoa lähetetty onnistuneesti\",\n     *       doneWithErrors:\n     *         \"Lähetys valmis, {filesUploaded} tiedostoa on lähetetty onnistuneesti, {filesWithErrors} tiedostossa oli virheitä\",\n     *       files: \"tiedostot\",\n     *       file: \"tiedosto\",\n     *     },\n     *     sv: {\n     *       inProgress: \"Adding {filesUploaded} of {filesTotal}\",\n     *       inProgressWithErrors:\n     *         \"Laddar upp {filesInProgress}, {filesUploaded} uppladdad av {filesTotal}, {filesWithErrors} misslyckades\",\n     *       done: \"Alla {filesTotal} har lagts till\",\n     *       doneWithErrors: \"Handling slutförd, {filesUploaded} har lagts till, {filesWithErrors} misslyckades\",\n     *       files: \"filer\",\n     *       file: \"fil\",\n     *     },\n     *     en: {\n     *       inProgress: \"Adding {filesUploaded} of {filesTotal}\",\n     *       inProgressWithErrors:\n     *         \"Uploading {filesInProgress}, {filesUploaded} uploaded of {filesTotal}, {filesWithErrors} failed\",\n     *       done: \"All {filesTotal} added successfully\",\n     *       doneWithErrors: \"Action completed, {filesUploaded} has been added successfully, {filesWithErrors} had errors\",\n     *       files: \"tiedostoa\",\n     *       file: \"tiedosto\",\n     *     },\n     *   }\n     */\n\n    this.statusLabelDefaults = {\n      fi: {\n        inProgress: \"Lähetetään {filesUploaded} lähetettävästä {filesTotal} tiedostosta\",\n        inProgressWithErrors: \"Lähetetään {filesInProgress} tiedostoa, lähetetty {filesUploaded} lähetettävästä {filesTotal} tiedostosta, {filesWithErrors} tiedostossa on virheitä\",\n        done: \"Kaikki {filesTotal} tiedostoa lähetetty onnistuneesti\",\n        doneWithErrors: \"Lähetys valmis, {filesUploaded} tiedostoa on lähetetty onnistuneesti, {filesWithErrors} tiedostossa oli virheitä\",\n        files: \"tiedostot\",\n        file: \"tiedosto\"\n      },\n      sv: {\n        inProgress: \"Adding {filesUploaded} of {filesTotal}\",\n        inProgressWithErrors: \"Laddar upp {filesInProgress}, {filesUploaded} uppladdad av {filesTotal}, {filesWithErrors} misslyckades\",\n        done: \"Alla {filesTotal} har lagts till\",\n        doneWithErrors: \"Handling slutförd, {filesUploaded} har lagts till, {filesWithErrors} misslyckades\",\n        files: \"filer\",\n        file: \"fil\"\n      },\n      en: {\n        inProgress: \"Adding {filesUploaded} of {filesTotal}\",\n        inProgressWithErrors: \"Uploading {filesInProgress}, {filesUploaded} uploaded of {filesTotal}, {filesWithErrors} failed\",\n        done: \"All {filesTotal} added successfully\",\n        doneWithErrors: \"Action completed, {filesUploaded} has been added successfully, {filesWithErrors} had errors\",\n        files: \"tiedostoa\",\n        file: \"tiedosto\"\n      }\n    };\n    /**\n     * Strings used for the status aria-label\n     */\n\n    this.statusMessageLabel = getLocaleString(this.statusLabelDefaults);\n    /**\n     * Property to change button label defaults on the component.\n     * @default {\n        fi: \"Lisää liite\",\n        sv: \"Lägg till en bilaga\",\n        en: \"Add an attachment\",\n      }\n     */\n\n    this.buttonLabelDefaults = {\n      fi: \"Lisää liite\",\n      sv: \"Lägg till en bilaga\",\n      en: \"Add an attachment\"\n    };\n    /**\n     * Label of button\n     * @default { fi: \"Lisää liite\", sv: \"Lägg till en bilaga\", en: \"Add an attachment\" }\n     */\n\n    this.buttonLabel = getLocaleString(this.buttonLabelDefaults);\n    /**\n     * accessible aria-Label of button\n     */\n\n    this.accessibleButtonLabel = undefined;\n    /**\n     * Theme of the input.\n     */\n\n    this.theme = \"\";\n    /**\n     * Makes the input component disabled. This prevents users from being able to\n     * interact with the upload component, and conveys its inactive state to assistive technologies.\n     */\n\n    this.disabled = false;\n    /**\n     * Controls the margin of the component.\n     */\n\n    this.margin = \"auto\";\n    /**\n     * Set whether the input is required or not. Please note that this is necessary for\n     * accessible inputs when the user is required to fill them. When using this property\n     * you need to also set “novalidate” attribute to your form element to prevent\n     * browser from displaying its own validation errors.\n     */\n\n    this.required = false;\n    /**\n     * Key used to set vertical alignment of action buttons\n     */\n\n    this.alignment = \"middle\";\n    /**\n     * Visually hides the groups labels in the editable table list used to display the list of files\n     */\n\n    this.hideGroups = false;\n    /**\n     * Map of string that contain list of uploaded files.\n     */\n\n    this.files = new Map();\n    /**\n     * Property to read if the internally used editable-table contains errors or not\n     */\n\n    this.valid = !this.required;\n    /**\n     * Property to change labelDefaults defaults on the component.\n     * normally you would handle these strings on an application level and override @label when needed\n     * @default { fi: \"Lisää liite\",sv: \"Lägg till en bilaga\",en: \"Add attachments\"}\n     */\n\n    this.labelDefaults = {\n      fi: \"Lisää liite\",\n      sv: \"Lägg till en bilaga\",\n      en: \"Add attachments\"\n    };\n    /**\n     * Label for the input.\n     * @default { fi: \"Lisää liite\",sv: \"Lägg till en bilaga\",en: \"Add attachments\"}\n     */\n\n    this.label = getLocaleString(this.labelDefaults);\n    /**\n     * Property to change descriptionDefaults defaults on the component.\n     * @default {\n        fi: \"Voit liittää {filetypes}-muotoisia tiedostoja sekä yleisimpiä videotiedostoja. Voit lähettää {maxbytes} verran tiedostoja yhdellä kertaa, ja lisätä enintään {maxfiles} liitettä kerrallaan.\",\n        sv: \"Du kan bifoga filer i flg. formater {filetypes} samt de vanligaste videofilerna. Du kan ladda upp {maxbytes} filer åt gången och lägga till upp till {maxfiles} bilagor åt gången.\",\n        en: \"You may attach the following filetypes: {filetypes} - as well as the most common video files. You can upload {maxbytes} of files at a time, and add up to {maxfiles} attachments at a time.\",\n      }\n     */\n\n    this.descriptionDefaults = {\n      fi: \"Voit liittää {filetypes}-muotoisia tiedostoja sekä yleisimpiä videotiedostoja. Voit lähettää {maxbytes} verran tiedostoja yhdellä kertaa, ja lisätä enintään {maxfiles} liitettä kerrallaan.\",\n      sv: \"Du kan bifoga filer i flg. formater {filetypes} samt de vanligaste videofilerna. Du kan ladda upp {maxbytes} filer åt gången och lägga till upp till {maxfiles} bilagor åt gången.\",\n      en: \"You may attach the following filetypes: {filetypes} - as well as the most common video files. You can upload {maxbytes} of files at a time, and add up to {maxfiles} attachments at a time.\"\n    };\n    /**\n     * Description for the upload component.\n     * @default {\n        fi: \"Voit liittää {filetypes}-muotoisia tiedostoja sekä yleisimpiä videotiedostoja. Voit lähettää {maxbytes} verran tiedostoja yhdellä kertaa, ja lisätä enintään {maxfiles} liitettä kerrallaan.\",\n        sv: \"Du kan bifoga filer i flg. formater {filetypes} samt de vanligaste videofilerna. Du kan ladda upp {maxbytes} filer åt gången och lägga till upp till {maxfiles} bilagor åt gången.\",\n        en: \"You may attach the following filetypes: {filetypes} - as well as the most common video files. You can upload {maxbytes} of files at a time, and add up to {maxfiles} attachments at a time.\",\n      }\n     */\n\n    this.description = getLocaleString(this.descriptionDefaults);\n    /**\n     * Defaults for the filelist's empty state.\n     * @default {\n        fi: \"Ei vielä lisättyjä tiedostoja.\",\n        sv: \"Inga filer har lagts till ännu.\",\n        en: \"No files added yet.\",\n       }\n     */\n\n    this.fileListEmptyDefaults = {\n      fi: \"Ei vielä lisättyjä tiedostoja.\",\n      sv: \"Inga filer har lagts till ännu.\",\n      en: \"No files added yet.\"\n    };\n    /**\n     * Label for the filelist's empty state.\n     * @default { fi: \"Ei vielä lisättyjä tiedostoja.\",sv: \"Inga filer har lagts till ännu.\",en: \"No files added yet.\"}\n     */\n\n    this.fileListEmpty = getLocaleString(this.fileListEmptyDefaults);\n    /**\n     * Display the input in error state along with an error message.\n     */\n\n    this.error = \"\";\n    /**\n     * Use maxBytes to specify the maximum size in Bytes of a file that can be uploaded.\n     */\n\n    this.maxBytes = 200000000;\n    /**\n     * Use maxBytesTotal to specify the maximum size in Bytes of All files combined that can be uploaded.\n     */\n\n    this.maxBytesTotal = undefined;\n    /**\n     * Use maxFiles to specify the maximum amount of files that can be uploaded\n     */\n\n    this.maxFiles = 99;\n    /**\n     * A string of commaseperated file type values that are allowed\n     * @example: .pdf,.doc,.docx\n     */\n\n    this.allowedExtensions = \"all\";\n    /**\n     * A string of commaseperated mime type values that are allowed\n     * @example: image/*,application/msword,\n     */\n\n    this.allowedMimetypes = \"*\";\n    /**\n     * Use multiple to allow the user to select multiple files when uploading\n     */\n\n    this.multiple = true;\n    /**\n     * Use limitSelection to enforce the value in allowedExtension & allowedMimetypes when selecting files,\n     * by default this is off, setting this to true will limit the users choices to what has been explicitly set\n     */\n\n    this.limitSelection = false;\n    /**\n     * Private functions\n     */\n\n    this.listenForActionEvents = () => {\n      this.element.addEventListener(\"duetEditableItemAction\", e => {\n        const detail = e.detail;\n        const {\n          action,\n          keyName,\n          originalEvent\n        } = detail;\n\n        switch (action) {\n          case \"delete\":\n            this.onDelete(keyName, originalEvent);\n            break;\n\n          case \"cancel\":\n            this.onCancel(keyName, originalEvent);\n            break;\n          // code block\n        }\n      });\n    };\n\n    this.verifyValidity = () => {\n      const {\n        invalid,\n        valid\n      } = this.getFilesAsArray();\n      const oldValid = this.valid;\n      this.valid = invalid.length === 0 && valid.length !== 0;\n\n      if (this.valid !== oldValid) {\n        this.duetState.emit({\n          originalEvent: undefined,\n          data: {\n            valid: this.valid,\n            from: \"componentWillRender\"\n          },\n          component: \"duet-upload\"\n        });\n      }\n    };\n\n    this.getGroupFromItemData = item => {\n      if (item.valid && item.progress === 100) {\n        // if the item has a group, move the file to that group instead\n        // of into the standard success group\n        if (item.group) {\n          return item.group;\n        }\n\n        return this.DefaultGroups.success;\n      } else if (item.progress > 0 && item.progress !== 100) {\n        return this.DefaultGroups.inprogress;\n      } else if (!item.valid) {\n        return this.DefaultGroups.failure;\n      } else if (item.group) {\n        return item.group;\n      } else {\n        return \"none\";\n      }\n    };\n\n    this.getItemHTMLFromItemData = (data, group) => {\n      if (group === this.DefaultGroups.success) {\n        return h(SuccessItem, {\n          data: data,\n          showLinks: this.showLinks\n        });\n      } else if (group === this.DefaultGroups.inprogress) {\n        return h(ProgressItem, {\n          progress: data.progress,\n          name: data.item.name\n        });\n      } else if (group === this.DefaultGroups.failure) {\n        return h(ErrorItem, {\n          data: data\n        });\n      } else if (data.group) {\n        return data.html;\n      } else {\n        return \"none\";\n      }\n    };\n\n    this.convertToDuetEditableTableItems = () => {\n      // we're always recreating the map - in order to force an update down stream.\n      const itemData = new Map(); //walk the files Map and convert to DuetEditableTableItemData\n\n      this.files.forEach((data, key, _originalMap) => {\n        const group = this.getGroupFromItemData(data);\n        const item = this.getItemHTMLFromItemData(data, group);\n        itemData.set(key, {\n          uid: data.uid,\n          item,\n          group\n        });\n      });\n      return itemData;\n    };\n\n    this.kick = debounce(() => {\n      this.tick = Date.now();\n    }, 30); // will trigger re-render\n\n    this.genHashName = () => Date.now().toString(36) + Math.random();\n\n    this.updateValueInMap = (item, key, value, kick = true) => {\n      const fileItem = this.files.get(item);\n      fileItem[key] = value;\n      this.files.set(item, fileItem);\n\n      if (kick) {\n        this.kick();\n      }\n    };\n\n    this.updateProgress = (ev, name) => {\n      const updateProgressHelper = percentComplete => {\n        this.updateValueInMap(name, \"progress\", percentComplete);\n        this.onProgress(name, percentComplete, ev);\n      };\n\n      if (ev.lengthComputable) {\n        const percentComplete = ev.loaded / ev.total * 100;\n        updateProgressHelper(percentComplete);\n      } else {\n        console.log(\"cant read progress\");\n      }\n    };\n\n    this.trackProgress = (name, remove = false) => {\n      if (remove) {\n        this.filesInProgress.delete(name);\n      } else {\n        this.filesInProgress.set(name, \"inprogress\");\n      }\n\n      if (this.filesInProgress.size === 0) {\n        this.onDone();\n      }\n    };\n\n    this.getFilesAsArray = () => {\n      const filesInQueue = [];\n      const filesInError = [];\n      this.files.forEach(value => {\n        if (value.valid && !value.deleted) {\n          filesInQueue.push(value);\n        } else if (!value.valid && !value.deleted) {\n          filesInError.push(value);\n        }\n      });\n      return {\n        valid: filesInQueue,\n        invalid: filesInError\n      };\n    };\n\n    this.resetFormFields = () => {\n      /**\n       * You cannot modify a FileList, nor remove single items from it\n       * This completely removes all items in the FileList\n       * We reset the form fields to always be able to re-upload files\n       * and because we handle all uploads and states internally in the component (not relying on native form elements)\n       */\n\n      /* TODO: it may be a good idea to just update the list so that this always matches what is in the files map,\n       * TODO: this would remove the capability of Re-uploading, unless we can catch and remove the user file from the form filelist before the upload is canceled by the browser\n       * TODO: but for now we'll just reset the form fields\n       */\n      this.nativeInput.value = \"\";\n    };\n\n    this.startUpload = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (ev, metaData = undefined) {\n        yield _this2.setFocus();\n        _this2.metaData = metaData;\n\n        _this2.nativeInput.click();\n\n        _this2.onUpload(ev, metaData);\n\n        ev.stopPropagation();\n        ev.preventDefault();\n        return;\n      });\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n    /**\n     * Eventlisteners for the XHR requests\n     */\n\n\n    this.transferComplete = name => {\n      this.updateValueInMap(name, \"progress\", 100, false);\n      this.trackProgress(name, true);\n    };\n\n    this.transferDone = (xhr, name, status) => {\n      this.updateValueInMap(name, \"status\", status, false);\n      this.updateValueInMap(name, \"uploaded\", true, false);\n\n      try {\n        const response = JSON.parse(xhr.response);\n        this.updateValueInMap(name, \"url\", response.url);\n      } catch (e) {\n        this.updateValueInMap(name, \"url\", null);\n        console.error(\"Server did not respond with expected response {url: string}\");\n      }\n\n      return;\n    };\n\n    this.transferDoneWithFailure = (xhr, name, status) => {\n      try {\n        const {\n          error\n        } = JSON.parse(xhr.response);\n        this.updateValueInMap(name, \"error\", {\n          message: error.message,\n          type: error.type\n        }, false);\n      } catch (e) {\n        console.error(\"Server did not respond with expected response error:{message: string, type: int}\");\n        this.updateValueInMap(name, \"error\", {\n          type: status\n        }, false);\n      }\n\n      this.updateValueInMap(name, \"valid\", false, true);\n    };\n\n    this.transferFailed = name => {\n      this.updateValueInMap(name, \"error\", getError(\"duet-upload-001\"));\n    };\n\n    this.transferCanceled = name => {\n      this.files.delete(name);\n      this.validateTotals(name);\n      this.kick();\n    };\n\n    this.validateTotals = name => {\n      const isTotalSizeOverMaxSize = validateTotalSizeIsAboveMax(this.files, this.maxBytesTotal);\n      const isTotalFileAmountAboveMax = validateTotalAmountIsAboveMax(this.files, this.maxFiles);\n\n      if (isTotalSizeOverMaxSize && name) {\n        this.updateValueInMap(name, \"error\", getError(\"duet-upload-202\"), false);\n      }\n\n      if (isTotalFileAmountAboveMax && name) {\n        this.updateValueInMap(name, \"error\", getError(\"duet-upload-301\"), false);\n      }\n\n      this.bytesMaxReached = isTotalSizeOverMaxSize;\n      this.fileMaxReached = isTotalFileAmountAboveMax;\n      return {\n        bytesMaxReached: isTotalSizeOverMaxSize,\n        fileMaxReached: isTotalFileAmountAboveMax\n      };\n    };\n\n    this.onDelete = (key, ev) => {\n      const deletedItem = this.files.get(key);\n      this.files.delete(key);\n      this.validateTotals();\n      this.kick();\n      this.duetDelete.emit({\n        originalEvent: ev,\n        data: {\n          deletion: deletedItem\n        },\n        component: \"duet-upload\"\n      });\n\n      if (!this.external) {\n        this.makeXHRDeleteRequest(deletedItem);\n      }\n\n      this.resetFormFields();\n    };\n\n    this.onCancel = (key, ev) => {\n      const cancelledItem = this.files.get(key);\n      this.files.delete(key);\n\n      if (!this.external) {\n        const {\n          xhr\n        } = cancelledItem;\n        xhr.abort();\n      } else {\n        this.kick();\n      }\n\n      this.resetFormFields();\n      this.duetCancel.emit({\n        originalEvent: ev,\n        data: {\n          cancelled: cancelledItem\n        },\n        component: \"duet-upload\"\n      });\n    };\n\n    this.onUpload = (ev, metaData) => {\n      this.duetUpload.emit({\n        originalEvent: ev,\n        metaData,\n        component: \"duet-upload\"\n      });\n    };\n\n    this.onBlur = ev => {\n      this.duetBlur.emit({\n        originalEvent: ev,\n        component: \"duet-upload\"\n      });\n    };\n\n    this.onProgress = (key, percentComplete, ev) => {\n      this.duetChange.emit({\n        originalEvent: ev,\n        data: {\n          key,\n          percentComplete\n        },\n        component: \"duet-upload\"\n      });\n    };\n\n    this.onFocus = ev => {\n      this.duetFocus.emit({\n        originalEvent: ev,\n        component: \"duet-upload\"\n      });\n    };\n\n    this.onDone = () => {\n      this.duetDone.emit({\n        component: \"duet-upload\",\n        data: {\n          files: this.files\n        }\n      });\n    };\n  }\n\n  watchValidHandler(newValue, oldValue) {\n    if (newValue !== oldValue) {\n      this.kick();\n    }\n  }\n  /**\n   * Component lifecycle events.\n   */\n\n\n  componentWillLoad() {\n    if (typeof this.statusMessageLabel === \"string\") {\n      this.internalStatusMessageLabel = sanitizeString(this.groups);\n    } else {\n      this.internalStatusMessageLabel = this.statusMessageLabel;\n    }\n\n    inheritGlobalTheme(this);\n    this.listenForActionEvents();\n  }\n\n  componentWillRender() {\n    // listen to the events from the component\n    this.verifyValidity();\n  }\n  /**\n   * XHR request utilities\n   */\n\n\n  makeXHRPostRequest(data) {\n    const xhr = new XMLHttpRequest();\n    const name = data.get(\"name\");\n    xhr.upload.addEventListener(\"progress\", ev => {\n      this.updateProgress(ev, name);\n    });\n    xhr.upload.addEventListener(\"load\", () => {\n      this.transferComplete(name);\n    });\n    xhr.upload.addEventListener(\"error\", () => {\n      this.transferFailed(name);\n    });\n    xhr.upload.addEventListener(\"abort\", () => {\n      this.transferCanceled(name);\n    });\n    return makeXhrRequest({\n      payload: {\n        data,\n        name\n      },\n      options: {\n        type: \"POST\",\n        uri: this.uri,\n        xhr,\n        argument: null,\n        headers: null\n      },\n      onFailure: this.transferDoneWithFailure,\n      onSuccess: this.transferDone,\n      onProgress: this.trackProgress\n    });\n  }\n\n  makeXHRDeleteRequest(data) {\n    const {\n      uid,\n      item\n    } = data;\n    const xhr = new XMLHttpRequest(); // don't present server issues to user on deletes, just remove them from the visible list\n\n    return makeXhrRequest({\n      payload: {\n        data: null,\n        name\n      },\n      options: {\n        type: \"DELETE\",\n        xhr,\n        uri: this.uri,\n        arguments: `?key=${uid}&name=${item.name}`,\n        headers: {\n          \"x-fileuid\": uid,\n          \"x-filename\": item.name\n        }\n      },\n      onFailure: this.transferDoneWithFailure,\n      onSuccess: this.transferDone,\n      onProgress: this.trackProgress\n    });\n  }\n  /**\n   * Component event handling.\n   */\n\n\n  onChange(ev) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const selectedFiles = Array.from((_a = _this3.nativeInput) === null || _a === void 0 ? void 0 : _a.files); // FileList is a nice array like structure but\n      // to ensure uniqueness of files we use a mapping structure and\n      // key to the name (makes it easier to delete as well)\n\n      if (selectedFiles) {\n        for (const item of selectedFiles) {\n          const {\n            valid,\n            errorMessage,\n            errorType,\n            errorSystem\n          } = validateFile(item, {\n            maxBytes: _this3.maxBytes,\n            allowedExtensions: _this3.allowedExtensions,\n            allowedMimetypes: _this3.allowedMimetypes\n          });\n\n          const uid = _this3.genHashName();\n\n          const fileListItem = {\n            uid,\n            item: item,\n            size: item.size,\n            meta: _this3.metaData,\n            uploaded: false,\n            valid,\n            error: {\n              type: valid ? undefined : errorType,\n              message: valid ? undefined : errorMessage,\n              system_message: valid ? undefined : errorSystem\n            },\n            progress: 0,\n            deleted: false,\n            xhr: false,\n            url: false\n          };\n\n          _this3.files.set(item.name, fileListItem); // validate that we haven't hit any maxfiles or maxbytes limits before we upload\n\n\n          const {\n            bytesMaxReached,\n            fileMaxReached\n          } = _this3.validateTotals(item.name);\n\n          if (bytesMaxReached) {\n            // in case one of the global maxes have been reached, invalidate the file\n            _this3.updateValueInMap(item.name, \"valid\", false, false);\n          } else if (fileMaxReached) {\n            // in case one of the global maxes have been reached, invalidate the file\n            _this3.updateValueInMap(item.name, \"valid\", false, false);\n          } else if (valid && !_this3.external) {\n            // if all is well AND external file upload handling has not been set, start upload\n            const data = new FormData();\n            data.append(\"file\", item);\n            data.append(\"uid\", uid);\n            data.append(\"name\", item.name);\n            data.append(\"metadata\", JSON.stringify({\n              uid,\n              url: _this3.uri,\n              size: item.size,\n              meta: fileListItem.meta\n            }));\n\n            try {\n              fileListItem.xhr = yield _this3.makeXHRPostRequest(data);\n            } catch (e) {\n              // in case one of the global maxes have been reached, invalidate the file\n              _this3.updateValueInMap(item.name, \"valid\", false, false);\n            }\n          } // kick the stat to force update\n\n\n          _this3.kick();\n        }\n      } // reset the form, so that a user may upload a file again (with the same name)\n\n\n      _this3.resetFormFields(); // reset the internal metaData state\n\n\n      _this3.metaData = undefined;\n\n      _this3.duetChange.emit({\n        originalEvent: ev,\n        data: {\n          files: _this3.files\n        },\n        component: \"duet-upload\"\n      });\n    })();\n  }\n  /**\n   * Sets focus on the specified `duet-input`. Use this method instead of the global\n   * `input.focus()`.\n   */\n\n\n  setFocus(options) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this4.nativeInput) {\n        _this4.nativeInput.focus(options);\n      }\n\n      return;\n    })();\n  }\n  /**\n   * Method for invoking the upload sequence\n   */\n\n\n  upload(metaData = undefined) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this5.setFocus();\n      _this5.metaData = metaData;\n\n      _this5.nativeInput.click();\n\n      return;\n    })();\n  }\n  /**\n   * Method for forcing a render of the upload list, element.files can be changed externally\n   * But it will only rerender on a new Map or a top Level change - this can be used to update\n   * the tabular data if the automatic re-render is no sufficient\n   */\n\n\n  refresh() {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      _this6.kick();\n\n      yield _this6.setFocus();\n    })();\n  }\n  /**\n   * Get list of files, divided in errors and valid sections\n   */\n\n\n  getFiles() {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this7.files || _this7.files.size === 0) {\n        return false;\n      }\n\n      return _this7.getFilesAsArray();\n    })();\n  }\n  /**\n   * Convenience method for updating the value of a key:value inside an item in the files attribute\n   */\n\n\n  updateValue(item, key, value) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      _this8.updateValueInMap(item, key, value);\n    })();\n  }\n  /**\n   * render() function\n   * Always the last one in the class.\n   */\n\n\n  render() {\n    const identifier = this.identifier || this.uploadId;\n    let caption = this.description.replace(/{maxfiles}/g, this.maxFiles.toString());\n    caption = caption.replace(/{maxbytes}/g, `${Math.floor(this.maxBytes / 1024 / 1024)} MB`);\n    caption = caption.replace(/{filetypes}/g, this.allowedExtensions.split(\",\").join(\", \"));\n    return h(Host, {\n      class: {\n        \"duet-m-0\": this.margin === \"none\"\n      }\n    }, h(\"duet-fieldset\", {\n      label: this.label,\n      caption: caption\n    }, h(\"slot\", {\n      name: \"header\"\n    }), !this.files.size && h(\"duet-label\", {\n      part: this.identifier ? `${this.identifier}-empty-state` : \"duet-upload-empty-state\",\n      theme: this.theme === \"turva\" ? \"turva\" : \"default\",\n      size: \"small\",\n      class: {\n        \"duet-upload-filelist-empty\": !this.files.size,\n        \"duet-upload-filelist\": true,\n        \"duet-upload-filelist-filled\": this.files.size\n      },\n      id: this.labelId,\n      for: identifier\n    }, this.fileListEmpty), !!this.files.size && h(\"slot\", {\n      name: \"fileheader\"\n    }), !!this.files.size && h(\"duet-upload-aria-status\", {\n      invalid: this.getFilesAsArray().invalid.length,\n      valid: this.getFilesAsArray().valid.length,\n      inprogress: this.filesInProgress.size,\n      total: this.files.size,\n      statusMessageLabel: this.internalStatusMessageLabel\n    }), !!this.files.size && h(\"duet-editable-table\", {\n      part: this.identifier ? `${this.identifier}-editable-table` : \"duet-upload-editable-table\",\n      \"aria-live\": \"polite\",\n      \"aria-relevant\": \"removals\",\n      accessibleRole: \"log\",\n      id: this.editableTableId,\n      groups: this.groups,\n      actions: this.actions,\n      hideGroups: this.hideGroups,\n      alignment: this.alignment,\n      items: this.convertToDuetEditableTableItems()\n    }), !!this.files.size && h(\"slot\", {\n      name: \"filefooter\"\n    }), h(\"duet-spacer\", {\n      size: \"large\"\n    }), !this.hideButton && h(\"duet-button\", {\n      id: this.buttonId,\n      onClick: this.startUpload,\n      \"accessible-controls\": identifier,\n      disabled: this.fileMaxReached,\n      \"accessible-label\": this.accessibleButtonLabel,\n      \"accessible-owns\": identifier,\n      size: \"small\",\n      variation: \"secondary\",\n      fixed: true,\n      icon: \"action-add-circle\",\n      part: this.identifier ? `${this.identifier}-button-upload` : \"duet-upload-button-upload\"\n    }, this.buttonLabel), h(\"duet-spacer\", {\n      size: \"medium\"\n    }), (this.fileMaxReached || this.bytesMaxReached) && h(\"duet-alert\", {\n      part: this.identifier ? `${this.identifier}-error-notification` : \"duet-upload-error-notification\"\n    }, this.fileMaxReached && getI18nError(\"duet-upload-301\"), this.bytesMaxReached && getI18nError(\"duet-upload-202\")), h(\"duet-spacer\", {\n      size: \"medium\"\n    }), h(\"duet-visually-hidden\", null, h(\"input\", {\n      ref: input => {\n        this.nativeInput = input;\n      },\n      accept: !this.limitSelection ? undefined : `${this.allowedMimetypes},${this.allowedExtensions}`,\n      onBlur: this.onBlur,\n      onFocus: this.onFocus,\n      onChange: e => this.onChange(e),\n      type: \"file\",\n      class: {\n        \"duet-upload\": true\n      },\n      disabled: this.disabled,\n      \"aria-hidden\": \"true\",\n      required: this.required,\n      name: this.name,\n      id: this.identifier,\n      multiple: this.multiple,\n      capture: \"user\"\n    }))));\n  }\n\n  get element() {\n    return getElement(this);\n  }\n\n  static get watchers() {\n    return {\n      \"valid\": [\"watchValidHandler\"]\n    };\n  }\n\n};\nDuetUpload.style = duetUploadCss;\nexport { DuetEditableTable as duet_editable_table, DuetEditableTableItem as duet_editable_table_item, DuetTable as duet_table, DuetUpload as duet_upload };","map":null,"metadata":{},"sourceType":"module"}